import { IGeometry, GeometryType, IFeature, IPopupInfo } from '@esri/arcgis-rest-types';
import { IAttachmentInfo } from '@esri/arcgis-rest-feature-layer';
import { DataSourceManager, IMDataSourceJson, IMDataSourceSchema, IMReversedDataSourceSchema, IntlShape, IMDataSourceInfo, ServiceDefinition, ImmutableObject, ImmutableArray } from 'jimu-core';
/**
 * All data source status is here, including data source instance status and data status (for QueriableDataSource).
 * * Instance status includes: NotCreated, Created, CreateError. <br/>
 *    When a data source is requested to be created, it is set to `NotCreated` at first.
 *    If a data source has never been used, there is no data source status.
 * * Data status includes: NotReady, Unloaded, Loading, Loaded, LoadError. <br/>
 *    When a QueriableDataSource is created, it is set as `NotReady` or `Unloaded` at first.
 *    If the data source is generated by widgets, the initial status will be `NotReady`, otherwise the initial status will be `Unloaded`.
 *    When widgets are ready to generate data, that is to say, the data source is ready to do query, widgets will change the status from `NotReady` to `Unloaded`.
 *    When widgets are not ready to generate data, widgets will change the status back to `NotReady`,
 *    then framework will help to clear source records, records and cache in data source instance.
 *    If `load()` is invoked, it will be set as `Loading`. If data is returned, it will be set as `Loaded`.
 *    If an error occurs, it will be set as `LoadError`.
 */
export declare enum DataSourceStatus {
    NotCreated = "NOT_CREATED",
    Created = "CREATED",
    CreateError = "CREATE_ERROR",
    /**
     * NotReady is for widget output data source only.
     * When output data source instance is created, the data is not ready for use.
     * Widget should dispatch an action (DataSourceStatusChanged) to make the data source ready for use.
     * If a data source status is not ready, the query should return an empty result.
     */
    NotReady = "NOT_READY",
    Unloaded = "UNLOADED",
    Loading = "LOADING",
    Loaded = "LOADED",
    LoadError = "LOAD_ERROR",
    /** @ignore */
    Saving = "SAVING",
    /** @ignore */
    Saved = "SAVED",
    /** @ignore */
    SaveError = "SAVE_ERROR",
    /** @ignore */
    Closed = "CLOSED",
    /** @ignore */
    Connecting = "CONNECTING",
    /** @ignore */
    Connected = "CONNECTED",
    /** @ignore */
    Closing = "CLOSING"
}
/**
 * The data source types that `jimu-core` supports.
 */
export declare enum DataSourceTypes {
    /** @ignore */
    SimpleLocal = "SIMPLE_LOCAL",
    /** @ignore */
    CSV = "CSV",
    /**
     * FeatureLayer data source is a `QueriableDataSource`, which is used to query ArcGIS feature service.
     * See {@link FeatureLayerDataSource}
     */
    FeatureLayer = "FEATURE_LAYER",
    /**
     * See {@link SceneLayerDataSource}
     */
    SceneLayer = "SCENE_LAYER",
    /**
     * GroupLayer data source is a data source set that may have child data sources. It is from group layer in a map service or a webmap/webscene.
     */
    GroupLayer = "GROUP_LAYER",
    /**
     * FeatureService data source is a data source set that may have child data sources. It is from the feature service.
     */
    FeatureService = "FEATURE_SERVICE",
    /**
     * MapService data source is a data source set that may have child data sources. It is from the map service.
     */
    MapService = "MAP_SERVICE",
    /**
     * SceneService data source is a data source set that may have child data sources. It is from the scene service.
     */
    SceneService = "SCENE_SERVICE"
}
/**
 * For now, we only support some layer service types.
 */
export declare enum SupportedLayerServiceTypes {
    FeatureLayer = "Feature Layer",
    Table = "Table",
    GroupLayer = "Group Layer",
    SceneLayerPoint = "Point",
    SceneLayer3DObject = "3DObject"
}
/**
 * For now, we only support some service types.
 */
export declare enum SupportedServiceTypes {
    FeatureService = "FeatureServer",
    MapService = "MapServer",
    SceneService = "SceneServer"
}
/**
 * For now, we only support some portal item types.
 * Please see [Items and item types](https://developers.arcgis.com/rest/users-groups-and-items/items-and-item-types.htm).
 */
export declare enum SupportedItemTypes {
    WebMap = "Web Map",
    WebScene = "Web Scene",
    FeatureService = "Feature Service",
    MapService = "Map Service",
    SceneService = "Scene Service",
    FeatureCollection = "Feature Collection"
}
/**
 * For now, we only support some layer types.
 * Please see [Layer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-Layer.html).
 */
export declare enum SupportedLayerTypes {
    FeatureLayer = "feature",
    MapImageLayer = "map-image",
    TileLayer = "tile",
    GroupLayer = "group",
    SceneLayer = "scene"
}
/**
 * Data source factory is used to create data source.
 */
export interface DataSourceFactory {
    createDataSource: (options: DataSourceConstructorOptions) => DataSource;
}
/**
 * A data record represents a record in a data source.
 */
export interface DataRecord {
    /** A reference of the data source object that has this record. */
    dataSource: DataSource;
    /**
     * The data is a plain object. The format is {key: value}, and the key is "jimuFieldName".
     *
     * The data before mapping use this schema: {fieldName: value}. We need to return this schema: {jimuFieldName: value}.
     */
    getData: () => any;
    /** @ignore */
    getDataBeforeMapping: () => any;
    /**
     * Return formatted record.
     */
    getFormattedData: (intl: IntlShape) => any;
    /**
     * Return the value of a specific field.
     */
    getFieldValue: (jimuFieldName: string) => any;
    /**
     * Return the formatted value of a specific field.
     */
    getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string;
    /** @ignore */
    convertBeforeMappingDataToData: (beforeMappingData: any) => any;
    /**
     * Return the data in JSON format, which is used to serialize data, and the key is "jimuFieldName".
     */
    toJson: () => any;
    /**
     * Return id of the record.
     */
    getId: () => string;
    /**
     * Set id of the record.
     */
    setId: (id: string) => void;
    /**
     * Return geometry of the record.
     */
    getGeometry: () => IGeometry;
}
/** @ignore */
export interface AttachmentInfo extends IAttachmentInfo {
    url?: string;
}
/** @ignore */
export interface AttachmentQueryOptions {
    attachmentTypes: string[];
    url: string;
    featureId: number | string;
}
/**
 * A DataRecordSet has a collection of data records. Similar to [FeatureSet](https://developers.arcgis.com/javascript/latest/api-reference/esri-tasks-support-FeatureSet.html)
 */
export interface DataRecordSet {
    /** The records of the set */
    records: DataRecord[];
    /** The fields names */
    fields?: string[];
    /** The data source where the data record set comes from. */
    dataSource?: DataSource;
}
/**
 * The result of data source's query method.
 */
export interface QueryResult {
    /**
     * The query parameters that generate the result.
     */
    queryParams: IMQueryParams;
    /**
     * Records of the query result.
     */
    records?: DataRecord[];
    /**
     * The jimuFieldName.
     */
    fields?: string[];
    /**
     * The number of result records.
     */
    count?: number;
    /**
     * Source version of data source.
     * @ignore
     */
    sourceVersion?: number;
}
/**
 * Query scope defines which data is returned when the query is executed in addition to the query parameters.
 */
export declare enum QueryScope {
    /** Use the query parameters directly to query. */
    InAllData = "IN_ALL_DATA",
    /** Use the query parameters and the filters configured in exb to query. */
    InRemoteConfigView = "IN_REMOTE_CONFIG_VIEW",
    /** Use the query parameters and the configured filters in data source and filters configured in exb to query. */
    InConfigView = "IN_CONFIG_VIEW",
    /** Use all of the appliyed query parameters to query. */
    InRuntimeView = "IN_RUNTIME_VIEW"
}
/**
 * Options when calling data source's load method.
 */
export interface QueryOptions {
    scope?: QueryScope;
    /** For load only.
     *  For local data source, you can use local id as widget id.
     */
    widgetId?: string;
    /** Force the query even if  the query parameters have not changed. */
    refresh?: boolean;
    /**
     * When execute query, the matched query is excluded.
     * Valid in runtime scope only.
     */
    excludeQuery?: WidgetDataSourcePair;
}
export interface WidgetDataSourcePair {
    dataSourceId: string;
    widgetId: string;
}
/** The base query parameter interface. */
export interface QueryParams {
    /**
     * Page number starts from 1, not 0.
     */
    page?: number;
    /**
     * Page size.
     */
    pageSize?: number;
}
export declare type IMQueryParams = ImmutableObject<QueryParams>;
/**
 * Query parameter which supports SQL.
 */
export interface SqlQueryParams extends QueryParams {
    /**
     * A where clause for the query.
     */
    where?: string;
    /**
     * The list of fields to be included in the returned result set.
     */
    outFields?: string[];
    /**
     * One or more `jimuFieldName` by which the features/records will be ordered.
     */
    orderByFields?: string[];
    /**
     * One or more `jimuFieldName` by which the values will be grouped for calculating the statistics.
     */
    groupByFieldsForStatistics?: string[];
}
export declare type IMSqlQueryParams = ImmutableObject<SqlQueryParams>;
/**
 * Query parameters for featuer layer.
 */
export interface FeatureLayerQueryParams extends SqlQueryParams {
    /**
     * Object IDs of records to be queried.
     */
    objectIds?: number[];
    /**
     * The geometry of the spatial filter.
     */
    geometry?: IGeometry;
    /**
     * If true, the geometry of each result feature will be returned.
     */
    returnGeometry?: boolean;
    /**
     * This option can be used to specify the number of decimal places for the returned geometries.
     */
    geometryPrecision?: number;
    /**
     * The definitions for one or more field-based statistics to be calculated.
     */
    outStatistics?: StatisticDefinition[];
    /**
     * If true, z-values are included in the results if the features have z-values. Otherwise, z-values are not returned.
     */
    returnZ?: boolean;
    /**
     * If true, m-values are included in the results if the features have m-values. Otherwise, m-values are not returned.
     */
    returnM?: boolean;
    /**
     * Specify the geodatabase version to be queried.
     */
    gdbVersion?: string;
    /**
     * The sqlFormat parameter can be either standard SQL-92 standard or it can use the native SQL of the underlying data store native.
     */
    sqlFormat?: 'none' | 'standard' | 'native';
}
export declare type IMFeatureLayerQueryParams = ImmutableObject<FeatureLayerQueryParams>;
/**
 * The definitions for one or more field-based statistics to be calculated.
 */
export interface StatisticDefinition {
    /**
     * Statistic type.
     */
    statisticType: 'count' | 'sum' | 'min' | 'max' | 'avg' | 'stddev' | 'var';
    /**
     * Field to execute statistic query.
     */
    onStatisticField: string;
    /**
     * Name of statistic query result.
     */
    outStatisticFieldName: string;
}
/**
 * The interface for all data sources.
 *
 * Conceptually, we have four types of data sources but all of them are created as data source object:
 * * Main data source: the data source user added in data panel.
 * * Data view: the data view user created in data panel.
 * * Local data source: when multiple widgets connnect to a main data source or a data view, they'll share the same data records. If you need to
 *    use a local data copy, you can create a local data source from a main data source by using `DataSourceManager.getInstance().createLocalDataSource()`.
 * * Local data view: a local data source created from a data view.
 *
 * Data view, local data source or local data view derived from the same main data source will share the same schema, same selection records, but may have different data records.
 * The schema is in main data source only.
 *
 * To share the selection between data source and view, we create a selection data view when creating the data source. The selection data source view id is: `${dataSourceId}-selection`.
 * When selecting records, the selected records are copied to the selection data view.
 *
 */
export interface DataSource {
    /** The data source id. */
    id: string;
    /** The type of the data source */
    type: string;
    /**
     * The data source JSON object in app config.
     */
    getDataSourceJson: () => IMDataSourceJson;
    /** Update data source JSON in data source instance */
    setDataSourceJson: (dsJson: IMDataSourceJson) => void;
    /** Return data source label. */
    getLabel: () => string;
    dataSourceManager: DataSourceManager;
    /**
     * Whether a data source contains child data sources.
     * A dataset data source should create all its child data sources before `ready()` is resolved.
     */
    isDataSourceSet: boolean;
    /**
     * True means the data source is a data view.
     * For local data source, this is false even the local data source is created from a data view.
     */
    isDataView: boolean;
    /**
     * True means the data source is a local data source.
     */
    isLocal: boolean;
    /** The local id of the data source. */
    localId?: string;
    /**
     * When current data source is created from an array of records, will save it in `sourceRecords`.
     * These two methods are use to update or get the source data.
     */
    setSourceRecords: (records: DataRecord[]) => void;
    /** Return the source records */
    getSourceRecords: () => DataRecord[];
    /**
     * The data schema is in "dataSourceJson",
     *    * For data source, use "jimuName" as key, and save the actual field name in the object.
     *    * For data source set, use "jimuChildId" as key, and save the actual child id in the object.
     * In many cases, we need to use the actual "childId" or "fieldName" to access info, so we can use this method to get a reverse schema for ease of use.
     */
    /** @ignore */
    getReversedConfigSchema: () => IMReversedDataSourceSchema;
    /** Get record by index */
    getRecord: (index: number) => DataRecord;
    /** Get record by id */
    getRecordById: (id: string) => DataRecord;
    /** Get records */
    getRecords: () => DataRecord[];
    /**
     * Update the records in the data source object only, does not update the source data.
     * See {@link DataSourceEditSourceOperations.updateRecords}
     */
    setRecords: (records: DataRecord[]) => void;
    nextRecord?: () => DataRecord;
    prevRecord?: () => DataRecord;
    /** The total records count depends on the current query */
    count?: number;
    /**
     * @ignore
     * JsonData may come from SSR, and the data uses jimuFieldName as key.
     */
    setJsonData: (jsonData: any[]) => void;
    /**
     * This function will clear the loaded records and won't clear the sourceRecords. Once the loaded records cleared, version in data source info will be updated.
     */
    clearRecords?: () => void;
    /**
     * @ignore
     * Clear records but don't add version in data source info.
     */
    clearRecordsNotAddVersion?: () => void;
    /**
     * Clear both sourceRecords and loaded records. Both source version and version in data source info will be updated.
     */
    clearSourceRecords: () => void;
    /**
     * @ignore
     * Clear source records and records, neither source version nor version will be added.
     */
    clearSourceRecordsNotAddVersion: () => void;
    /**
     * The schema returned here is the merged result of the configured schema and the fetched schema.
     */
    getSchema: () => IMDataSourceSchema;
    setSchema: (schema: IMDataSourceSchema) => void;
    /**
     * @ignore
     * The schema contains all fields defined in the actual service. This method will return the fields
     * user configured in the widget which generates output data source.
     */
    getSelectedFields: () => string[];
    setSelectedFields: (jimuNames: string[]) => void;
    /**
     * Fetch data schema from an actual data source. If it's a statistic data source, we won't fetch schema.
     */
    fetchSchema: () => Promise<IMDataSourceSchema>;
    getFetchedSchema: () => IMDataSourceSchema;
    setFetchedSchema: (schema: IMDataSourceSchema) => void;
    /** Return data source status. */
    getStatus: () => DataSourceStatus;
    /** Update data source status. */
    setStatus?: (status: DataSourceStatus) => void;
    /** Return data source count status. */
    getCountStatus: () => DataSourceStatus;
    /** Update data source count status. */
    setCountStatus?: (status: DataSourceStatus) => void;
    /** Return data source version. */
    getVersion: () => number;
    /** Update data source version. */
    addVersion?: () => void;
    /**
     * When current data source is created from an array of records, it will be saved in `sourceRecords`.
     * Return the version of `sourceRecords`.
     */
    getSourceVersion: () => number;
    /**
     * When current data source is created from an array of records, it will be saved in `sourceRecords`.
     * Add the version of `sourceRecords`.
     * `setSourceRecords` will add the version by default.
     */
    addSourceVersion: () => void;
    /** Return the data source id field. */
    getIdField: () => string;
    destroy: () => void;
    /**
     * Ready is resolved means the data source instance is ready for use.
     */
    ready: () => Promise<void | any>;
    /** Return the data source info in redux store. */
    getInfo: () => IMDataSourceInfo;
    /**
     * Return null means the data source is a non-spatial data source.
     * @ignore
     */
    getGeometryType: () => GeometryType;
    /**
     * For most of the widget output data source, it has an original data source from which it's generated.
     * For the configured data source, return null.
     * @ignore
     */
    getOriginDataSources?: () => DataSource[];
    /**
     * Return the derived data views and local data sources.
     */
    getAllDerivedDataSources: () => DataSource[];
    /** Return child data sources of a parent data source. */
    getChildDataSources?: () => DataSource[];
    /**
     * Get child data source by `jimuChildId`. You can get `jimuChildId` by `getJimuChildId()`.
     */
    getChildDataSource?: (jimuChildId: string) => DataSource;
    /**
     * Get the actual data source id by `jimuChildId`.
     * @ignore
     */
    getChildDataSourceId?: (jimuChildId: string) => string;
    /**
     * @ignore
     * The jimu child id is similar to the jimuFieldName, and widgets should use the jimuChildId instead of the childId to make data mapping work.
     */
    getJimuChildId?: (childId: string) => string[];
    /**
   * The parent data source of this data source, mull means it's a root data source.
   */
    parentDataSource: DataSource;
    jimuChildId: string;
    /** Return the root data source. */
    getRootDataSource: () => DataSource;
    /** The data source which this data source derives from. */
    belongToDataSource?: DataSource;
    /** Return the main data source. */
    getMainDataSource: () => DataSource;
    /** The data view id configured in Json. */
    dataViewId?: string;
    /** Return all data views created from a main data source. */
    getDataViews: () => DataSource[];
    /** Get data view by data view id. */
    getDataView: (dataViewId: string) => DataSource;
    /** Return all local data sources created from a main data source or data view. */
    getLocalDataSources: () => DataSource[];
    /** Get local data source by local Id. */
    getLocalDataSource: (localId: string) => DataSource;
    /**
     * @ignore
     * These methods will update the source data of data source.
     *
     * The data source object provides an interface interact with its source,
     * the source 1. may come from AGOL/portal item or a remote database, 2. may come from an array directly.
     * If the source comes from AGOL/portal item or a remote database, these operations will use JS API or REST API to apply edits to it.
     * If the source comes from an array directly, will save it in `sourceRecords` and these operations will edit the `sourceRecords`.
     *
     * The data source object also contains a subset of its source, the subset is saved in `records` and loaded from source.
     * To update the subset, please use `setRecords()`, to update the source, please use these operations.
     * To get the subset, please use `getRecords()`, to get the source:
     *   - for data source which comes from an array directly, please use `getSourceRecords()`,
     *   - for data source which comes from AGOL/portal item or a remote database:
     *     - for queriable data source, please use `query()` or `load()`,
     *     - for stream data source, please use `onData` (TBD).
     */
    updateRecords: (records: DataRecord[]) => Promise<boolean>;
    addRecord: (record: DataRecord) => Promise<DataRecord>;
    updateRecord: (record: DataRecord) => Promise<boolean>;
    deleteRecord: (index: number) => Promise<boolean>;
    deleteRecordById: (id: string) => Promise<boolean>;
    /**
     * Data source may have selected data, use selection view to handle it.
     *  - All user selected records will be saved in `sourceRecords` of selection view,
     *  - If widget add a filter to selection view, `sourceRecords` will still be the same and `records` will be the filtered result,
     *  - `records` of selection view are updated automatically whenever `sourceRecords` or SQL changes,
     *  - Selected record ids of main data source info are always same as `records` of selection view,
     *  - Selected record ids of data view info are subset of selected record ids of main data source info
     *    since some selected records of main data source may do not match SQL of data view,
     *  - If query or load selection view, the view will load ArcGIS JS API and then will create a client-side feature layer to do query,
     *  - If open no_selection view and `sourceRecords` of selection view is empty, will use `records` of no_selection view as `sourceRecords` of selection view,
     *  - `records` of no_selection view are updated automatically, too.
     *  - No_selection view only loads one page, won't use all records of no_selection view as default value of selection view.
     */
    /**
     * @ignore
     * Select record by index.
     */
    selectRecord?: (index: number) => void;
    /**
    * @ignore
    * Select record by indices.
    */
    selectRecords?: (indexes: number[]) => void;
    /**
     * Select a record by id.
     * When select record by id, we can pass in the records. So when the selected records are not in the data source, we can add it in.
    */
    selectRecordById?: (id: string, record?: DataRecord) => void;
    /** Select records by ids */
    selectRecordsByIds?: (ids: string[], records?: DataRecord[]) => void;
    /** Get selected records */
    getSelectedRecords?: () => DataRecord[];
    /** Get selected record indexes*/
    getSelectedRecordIndexes?: () => number[];
    /** Get selected record ids*/
    getSelectedRecordIds?: () => string[];
    getSelectedRecordIdsFromInfo: () => ImmutableArray<string>;
    setSelectedRecordIdsToInfo?: (ids: string[], triggerDataSource: DataSource) => void;
    clearSelection?: () => void;
    /**
     * Whether listen selected records from other data sources which are derived from the same main data source.
     * If true, will update selected record ids of current data source info when selecting records via other derived data sources.
     * If false, won't change selected record ids when selecting records via other derived data sources. Will update selected record ids only when selecting records via current data source itself.
     *
     * Main data source and its data views will listen selected records by default, local data source does not listen selected records by default.
     */
    setListenSelection: (listen: boolean) => void;
    /** Return whether listen selection. */
    getListenSelection: () => boolean;
    /**
     * If selected records are not loaded in the current data source, they will be concatenated to the end of records array.
     * For example, record 1 is selected in data view 1 and it is not loaded in data view 2 (record 1 actually matches query params of data view 2),
     *      dataView2.getRecordsWithSelection() will return all loaded records in data view 2 and record 1.
     */
    getRecordsWithSelection: () => DataRecord[];
}
/**
 * `QueriableDataSource` extends `DataSource` and add query capability. A queriable data source must
 * have an `URL` to execute the query.
 *
 * The current default query implementation supports pagination. It allows mulitple widgets to apply queries on the same data source,
 * all of which are merged by using the `AND` logic operator.
 *
 * When execute a query, in addition to the passed in query parameters, all configured queries and
 * all other widgets applied queries are merged by using the `AND` logic operator.
 *
 * When a query is executed against a data view, the query from its main data source is used as well.
 */
export interface QueriableDataSource extends DataSource {
    /** The data source URL */
    url: string;
    lastUpdateTime: Date;
    /**
     * Execute the query against the service and update the internal data records, pagination is supported.
     * When call this method, the real query is returnd by `getRealQueryParams`.
     *
     * Pagination:
     * The pagination properties in the passed in query parameter may be not the same as the real query pagination that is sent to the service.
     * The real query pagination is defined in the data source setting.
     */
    load: (query: QueryParams, options?: QueryOptions) => Promise<DataRecord[]>;
    /**
     * Load record by id, do not consider other queries.
     */
    loadById: (id: string, refresh?: boolean) => Promise<DataRecord>;
    /** Load the records count. */
    loadCount: (query: QueryParams, options?: QueryOptions) => Promise<number>;
    /**
     * Update the data source query without executing the actual query.
     */
    updateQueryParams: (query: QueryParams, widgetId: string) => void;
    /**
     * Get the current query parameters. The current query parameters contain all applied queries.
     */
    getCurrentQueryParams: (excludeOption?: WidgetDataSourcePair) => QueryParams;
    getCurrentQueryId: () => string;
    /** Get the queries applied in runtime. If the excludeWidgetId is passed in, the queries of this widget will be excluded. */
    getRuntimeQueryParams: (excludeWidgetId?: string) => QueryParams;
    /**
     * Get the user config query parameters.
     */
    getConfigQueryParams: () => QueryParams;
    /** Get the query parameters configured in remote (not in exb). */
    getRemoteQueryParams: () => QueryParams;
    /**
     * Merge the new query to base query by using `AND`, and return the merged result.
     * If any query is undefined/null, it will be ignored.
     */
    mergeQueryParams: (baseQuery: QueryParams, newQuery: QueryParams) => QueryParams;
    /**
     * When do query/load, we do not fire the query request directly. Instead, we'll consider the data source's config/current query parameter.
     *  * For load: we'll merge the configured query parameter if it has, and all widget applied queries.
     *  * For query, we'll merge the current query parameter and the configured query parameter it has.
     */
    getRealQueryParams: (query: QueryParams, flag: 'query' | 'load', options?: QueryOptions) => QueryParams;
    /**
     * Execute query against the service only, do NOT update the internal data records.
     * The actural query parameters are generated by `getRealQueryParams`.
     *
     * To query count, please use `queryCount`.
     */
    query: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>;
    /** Query record by id */
    queryById: (id: string) => Promise<DataRecord>;
    /** Query count */
    queryCount: (query: QueryParams, options?: QueryOptions) => Promise<QueryResult>;
    /**
     * The page size here defines the records this method returns, which are not the actual query pageSize. Will use a fixed pageSize to query and cache data.
     */
    getRecordsByPage: (page: number, pageSize: number) => DataRecord[];
    getPagesData: () => {
        [page: number]: DataRecord[];
    };
    setPagesData: (pages: {
        [page: number]: DataRecord[];
    }) => void;
    /**
     * Get real query page depends on the widget's request page.
     */
    getRealQueryPages: (pageSize: number, page: number) => number[];
    getQueryPageSize: () => number;
    /**
     * Null means there is no record count limit, and will return all records from the service.
     */
    getMaxRecordCount: () => number;
    /** @ignore */
    getSaveStatus: () => DataSourceStatus;
    /** @ignore */
    setSaveStatus?: (status: DataSourceStatus) => void;
    /** Override parent interface to get correct type. */
    getDataViews: () => QueriableDataSource[];
    getDataView: (dataViewId: string) => QueriableDataSource;
    getMainDataSource: () => QueriableDataSource;
    /** If the return value > 0, auto refresh is enabled. */
    getAutoRefreshInterval: () => number;
    getLastRefreshTime: () => Date;
    startAutoRefresh: () => void;
    stopAutoRefresh: () => void;
    allowToExportData: () => Promise<boolean>;
    /**
    * If selected records are not loaded in the current data source, will concat them to the end of records array.
    * See {@link getRecordsWithSelection} for details.
    */
    getRecordsByPageWithSelection: (page: number, pageSize: number) => DataRecord[];
}
/** @ignore */
export interface LoadableDataSource extends DataSource {
    url: string;
    /**
     * Load all data records.
     */
    load: () => Promise<DataRecord[]>;
}
/**
 * Parameters of `DataSource`'s constructor.
 */
export interface DataSourceConstructorOptions {
    /** The data source id. */
    id: string;
    /**
     * dataSourceJson or belongToDataSource is either-or option.
     * Pass dataSourceJson will create a main data source.
     * Pass belongToDataSource will create data view or local data source.
     */
    dataSourceJson?: IMDataSourceJson;
    /** Data source that the to-be-created data source belongs to. */
    belongToDataSource?: DataSource;
    /**
     * If dataViewId exists, a data view will be created.
     */
    dataViewId?: string;
    /**
     * if localId exists, a local data source will be created.
     */
    localId?: string;
    dataSourceManager?: DataSourceManager;
    parentDataSource?: DataSource;
    jimuChildId?: string;
    /**
    * If all of the data is holded in the data source instance, put the data in the source records.
    * For others, the data may come from AGOL/portal item or a remote database.
    *
    * Only main data source or selection view will save source records,
    * if current data source is a view of selection view, will use selection view's source records, else,
    * will use main data source's source records.
    */
    sourceRecords?: FeatureDataRecord[];
}
/**
 * @ignore
 */
export declare class DataSourceError extends Error {
    dataSourceId: string;
    constructor(id: any, message: any);
}
/** @ignore */
export interface CodedValue {
    value: string | number;
    label: string;
    render?: (item: CodedValue) => any;
}
/**
 * Record of feature layer data source.
 */
export interface FeatureDataRecord extends DataRecord {
    /** The feature returned from query REST API or the ArcGIS JS API [Graphic](https://developers.arcgis.com/javascript/latest/api-reference/esri-Graphic.html) object */
    feature: IFeature | __esri.Graphic;
    dataSource: FeatureLayerDataSource | SceneLayerDataSource;
    attachmentInfos: AttachmentInfo[];
    queryAttachments: (attachmentTypes?: string[]) => Promise<AttachmentInfo[]>;
    getSymbolPreviewHTML: () => Promise<HTMLElement>;
    getData: () => {
        [key: string]: any;
    };
    getFormattedFieldValue: (jimuFieldName: string, intl: IntlShape) => string;
    getDataBeforeMapping: () => {
        [key: string]: any;
    };
    getOriginData: () => {
        [key: string]: any;
    };
    toJson: () => IFeature | __esri.Graphic;
    getId: () => string;
    setId: (id: string) => void;
    getGeometry: () => IGeometry;
    setFeature: (feature: IFeature | __esri.Graphic) => void;
    getFeature: () => IFeature | __esri.Graphic;
}
export interface SimpleLocalDataSource extends DataSource {
    type: DataSourceTypes.SimpleLocal;
}
export interface CsvDataSource extends LoadableDataSource {
    type: DataSourceTypes.CSV;
    doLoad: () => Promise<DataRecord[]>;
}
/**
 * `FeatureLayerDataSource` is created from a single feature layer of feature service, map service or webmap/webscene.
 */
export interface FeatureLayerDataSource extends QueriableDataSource {
    type: DataSourceTypes.FeatureLayer;
    url: string;
    portalUrl?: string;
    itemId?: string;
    layerId?: string;
    /** The ArcGIS JS API [FeatureLayer](https://developers.arcgis.com/javascript/latest/api-reference/esri-layers-FeatureLayer.html) object. */
    layer?: __esri.FeatureLayer;
    /** Return the current GDB version. */
    getGDBVersion: () => string;
    /** Change the layer GDB version. */
    changeGDBVersion: (gdbVersion: string) => void;
    createJSAPILayerByDataSource: () => Promise<__esri.FeatureLayer>;
    setAssociatedDataSource: (associatedDataSource: SceneLayerDataSource) => void;
    getAssociatedDataSource: () => SceneLayerDataSource;
    getPopupInfo: () => Promise<IPopupInfo>;
    supportSymbol: () => boolean;
    supportAttachment: () => boolean;
    getLayerDefinition: () => ServiceDefinition;
    load: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<DataRecord[]>;
    loadCount: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<number>;
    query: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>;
    queryCount: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>;
    queryById: (id: string) => Promise<FeatureDataRecord>;
    selectRecordById: (id: string, record?: FeatureDataRecord) => void;
    selectRecordsByIds: (ids: string[], records?: FeatureDataRecord[]) => void;
    getIdField: () => string;
    getGeometryType: () => GeometryType;
    setJsonData: (data: Array<IFeature | __esri.Graphic>) => void;
    getConfigQueryParams: () => FeatureLayerQueryParams;
    mergeQueryParams: (baseQuery: FeatureLayerQueryParams, newQuery: FeatureLayerQueryParams) => FeatureLayerQueryParams;
    getRealQueryParams: (query: any, flag: 'query' | 'load', options?: QueryOptions) => FeatureLayerQueryParams;
    fetchSchema: () => Promise<IMDataSourceSchema>;
    getFieldCodedValueList: (jimuFieldName: string, record?: FeatureDataRecord) => CodedValue[];
}
/**
 * `GroupLayerDataSource` is created from a group layer of map service or webmap/webscene.
 */
export interface GroupLayerDataSource extends DataSource {
    type: DataSourceTypes.GroupLayer;
    layer?: __esri.GroupLayer | __esri.Sublayer;
    getServiceDefinition: () => ServiceDefinition;
}
/**
 * `FeatureServiceDataSource` is created from feature service.
 */
export interface FeatureServiceDataSource extends DataSource {
    type: DataSourceTypes.FeatureService;
    getServiceDefinition: () => ServiceDefinition;
}
/**
 * `MapServiceDataSource` is created from map service or webmap/webscene.
 */
export interface MapServiceDataSource extends DataSource {
    type: DataSourceTypes.MapService;
    layer?: __esri.MapImageLayer | __esri.TileLayer;
    getServiceDefinition: () => ServiceDefinition;
}
/**
 * `SceneServiceDataSource` is created from scene service or webscene.
 */
export interface SceneServiceDataSource extends DataSource {
    type: DataSourceTypes.SceneService;
    getServiceDefinition: () => ServiceDefinition;
}
/**
 * `SceneLayerDataSource` is created from a single scene layer of scene service or webscene.
 */
export interface SceneLayerDataSource extends QueriableDataSource {
    type: DataSourceTypes.SceneLayer;
    getAssociatedDataSource: () => FeatureLayerDataSource;
    getPopupInfo: () => Promise<IPopupInfo>;
    layer?: __esri.SceneLayer;
    createJSAPILayerByDataSource: () => Promise<__esri.SceneLayer>;
    url: string;
    portalUrl?: string;
    itemId?: string;
    layerId?: string;
    /** Return the current GDB version. */
    getGDBVersion: () => string;
    /** Change the layer GDB version. */
    changeGDBVersion: (gdbVersion: string) => void;
    supportSymbol: () => boolean;
    supportAttachment: () => boolean;
    getLayerDefinition: () => ServiceDefinition;
    load: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<DataRecord[]>;
    loadCount: (query: FeatureLayerQueryParams, options?: QueryOptions) => Promise<number>;
    query: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>;
    queryCount: (queryProperties: FeatureLayerQueryParams) => Promise<QueryResult>;
    queryById: (id: string) => Promise<FeatureDataRecord>;
    selectRecordById: (id: string, record?: FeatureDataRecord) => void;
    selectRecordsByIds: (ids: string[], records?: FeatureDataRecord[]) => void;
    getIdField: () => string;
    getGeometryType: () => GeometryType;
    setJsonData: (data: Array<IFeature | __esri.Graphic>) => void;
    getConfigQueryParams: () => FeatureLayerQueryParams;
    mergeQueryParams: (baseQuery: FeatureLayerQueryParams, newQuery: FeatureLayerQueryParams) => FeatureLayerQueryParams;
    getRealQueryParams: (query: any, flag: 'query' | 'load', options?: QueryOptions) => FeatureLayerQueryParams;
    fetchSchema: () => Promise<IMDataSourceSchema>;
    getFieldCodedValueList: (jimuFieldName: string, record?: FeatureDataRecord) => CodedValue[];
}
/**
 * @ignore
 * @deprecated
 */
export interface FeatureQueryDataSource extends FeatureLayerDataSource {
}
/** *********************************************************** Data sources ***********************************************/
